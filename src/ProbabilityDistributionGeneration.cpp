#include <ProbabilityDistributionGeneration.hpp>
#include <algorithm>

/**
 * Create and return a vector of probabilities of the given size. Each
 * probability is equal to 1/size.
 * @param[in]  size  Size of the resulting vector of probabilitiess
 * @return           A vector of the given size with uniformly distributed probabilities.
 */
std::vector<long double> ProbabilityDistributionGeneration::uniform(unsigned size) {
    std::vector<long double> v(size);
    
    for (unsigned i=0; i<size; i++) {
        v[i] = 1.0L/size;
    }
    
    return v;
}

/**
 * Create and return a vector of probabilities of the given size. The
 * probabilities follow the broken stick distribution, they are the expected
 * values of the length of the pieces resulting from a partition of a segment
 * of length 1 in n parts using n-1 randomly uniformly distributed points.
 * @param[in]  rng   Random number generator to use for generating the probabilities.
 * @param[in]  size  Size of the resulting vector of probabilitiess.
 */
std::vector<long double> ProbabilityDistributionGeneration::brokenstick(unsigned size) {
    /*
     * https://www.sciencedirect.com/science/article/abs/pii/S0022519376800276
     * Equivalent to Eq. 1 but reverse order (v[0] is the greatest here)
     */
    std::vector<long double> v(size);

    for (unsigned k=1; k<=size; k++) {
        unsigned i = size-k;
        
        v[i] = 0;
        for (unsigned j=1; j<=k; j++) {
            v[i] += 1.0L/(size-j+1);
        }
        v[i] /= size;
    }

    // Equivalent formula
    // for (unsigned i=1; i<size+1; i++) {
    //     long double s = 0;
    //     for (unsigned j=0; j<size-i+1; j++) {
    //         s += 1.0L/(size - j);
    //     }
    //     v[i-1] = s/size;
    // }

    return v;
}

/**
 * Create and return a vector of probabilities of the given size. The
 * probabilties are generated following a geometric distribution with parameter
 * p.
 * @param[in]  p     "Probability of success" prameter of the geometric distribution.
 * @param[in]  size  Size of the resulting vector of probabilitiess.
 */
std::vector<long double> ProbabilityDistributionGeneration::geometric(long double p, unsigned size) {
    /*
     * p -> "probability of success" parameter
     * m -> defined for x \in {1,2,...,m}
     * q -> 1 - p
     *
     * PMF of geometric distribution is
     * p(X=x) = q^(x-1) * p
     *
     * CDF of geometric distribution is
     * P(X=x) = 1 - q^x
     *
     * CDF of truncated discrete distribution defined for x \in {a+1, a+2, ..., b}
     * p(X=x | a < X <= b) = p(X=x) / (P(X=b) - P(X=a))
     *
     * In our case, a right-truncated distribution:
     * a = 0, b = m
     *
     * So we have:
     * p(X=x | X <= m) = p(X=x) / P(X=b)
     *
     * Which becomes:
     * p(X=x | X <= m) = q^(x-1) * p / (1 - q^m)
     *
     * We can rewrite it as:
     * p(X=x | X <= m) = c*d
     *
     * With d depending on x:
     * d = q^(x-1)
     *
     * and c being constant:
     * c = p / (1 - q^m)
     */
    
    std::vector<long double> v(size);
    const unsigned m = size;
    const long double q = 1 - p;
    const long double c = p / (1 - std::pow(q, m));

    for (unsigned i=0; i<m; i++) {
        long double d = std::pow(q, i);
        v[i] = c * d;
    }

    return v;
}

std::vector<long double> ProbabilityDistributionGeneration::powerlaw(long double alpha, unsigned size) {
    /*
     * p(X=x | X <= size) = A * x^-alpha
     * A = sum (from i=1 to size) i^-alpha
     */
    
    std::vector<long double> v(size);
    long double A = 0;
    
    for (unsigned i=0; i<size; i++) {
        long double q = std::pow(i+1, -alpha);
        A += q;
        v[i] = q;
    }
    for (unsigned i=0; i<size; i++) {
        v[i] /= A;
    }
    
    return v;
}

/**
 * Return the smallest probability that would be generated by a right truncated geometric distribution.
 * @param[in]  p     "Probability of success" prameter of the geometric distribution.
 * @param[in]  size  Number of probabilities for the truncation.
 */
long double ProbabilityDistributionGeneration::geometric_smallest_probability(long double p, unsigned size) {
    // could simply calculate the last element, but this ensures we use the exact same formula
    std::vector<long double> v = ProbabilityDistributionGeneration::geometric(p, size);
    return *std::min_element(v.begin(), v.end());
}

long double ProbabilityDistributionGeneration::powerlaw_smallest_probability(long double alpha, unsigned size) {
    // could simply calculate the last element, but this ensures we use the exact same formula
    std::vector<long double> v = ProbabilityDistributionGeneration::powerlaw(alpha, size);
    return *std::min_element(v.begin(), v.end());
}
